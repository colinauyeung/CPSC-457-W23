#include <cstdio>
#include <cstdlib>
#include <atomic>
#include <pthread.h>
#include<iostream>
#include<utility>
#include<vector>
#include <algorithm>

#include <atomic>

const int nthreads = 4;

int nums[][2][2] = {{{120,111},{139,43}},{{152,120},{5,167}},{{9,101},{185,104}},{{162,106},{59,97}},{{137,200},{70,26}},
{{142,118},{147,124}},{{118,1},{1,63}},{{43,125},{96,199}},{{147,140},{135,192}},{{30,39},{23,136}},
{{66,145},{146,111}},{{32,87},{92,135}},{{37,114},{199,92}},{{31,102},{44,190}},{{132,7},{83,127}},
{{141,156},{6,44}},{{133,40},{65,50}},{{185,157},{59,146}},{{37,70},{185,79}},{{75,82},{180,113}},
{{20,64},{108,186}},{{141,108},{5,102}},{{44,169},{131,17}},{{198,148},{132,93}},{{59,116},{96,153}},
{{49,44},{5,5}},{{197,178},{170,165}},{{44,18},{79,33}},{{82,137},{187,120}},{{60,107},{39,75}},
{{21,198},{52,87}},{{1,106},{131,176}},{{31,187},{42,4}},{{55,111},{43,200}},{{24,57},{157,122}},
{{49,10},{41,57}},{{89,9},{52,71}},{{148,61},{105,2}},{{126,126},{11,186}},{{75,132},{74,126}},
{{163,89},{189,192}},{{176,32},{106,2}},{{90,189},{133,117}},{{72,127},{175,173}},{{103,47},{150,105}},
{{74,193},{88,126}},{{127,20},{46,125}},{{58,81},{75,50}},{{58,61},{136,20}},{{83,128},{96,146}},
{{139,81},{151,110}},{{184,63},{160,83}},{{3,175},{147,49}},{{22,123},{93,8}},{{99,165},{13,72}},
{{27,109},{123,146}},{{15,87},{79,134}},{{72,169},{22,179}},{{33,191},{134,70}},{{180,199},{59,29}},
{{64,171},{196,96}},{{82,107},{164,48}},{{86,40},{38,137}},{{170,80},{55,39}},{{193,153},{135,167}},
{{172,2},{47,182}},{{186,127},{134,122}},{{35,61},{23,64}},{{197,15},{170,85}},{{18,41},{140,47}},
{{193,98},{17,23}},{{103,114},{41,171}},{{93,73},{120,114}},{{134,183},{137,159}},{{118,112},{64,155}},
{{19,148},{195,169}},{{11,131},{23,86}},{{144,2},{94,33}},{{88,72},{101,24}},{{115,52},{171,84}},
{{10,122},{166,193}},{{34,157},{144,127}},{{86,142},{192,4}},{{48,35},{196,129}},{{129,64},{10,149}},
{{108,70},{71,192}},{{125,179},{6,47}},{{117,111},{76,7}},{{11,187},{17,137}},{{9,130},{179,196}},
{{88,13},{75,22}},{{135,81},{108,18}},{{106,108},{18,71}},{{34,140},{21,165}},{{160,28},{17,110}},
{{117,184},{101,27}},{{142,148},{184,116}},{{12,82},{98,191}},{{157,69},{5,93}},{{133,22},{166,56}},
{{185,44},{118,63}},{{22,65},{89,26}},{{144,167},{61,49}},{{151,191},{122,173}},{{168,183},{62,19}},
{{105,192},{163,115}},{{10,123},{95,57}},{{59,14},{178,124}},{{102,110},{158,168}},{{118,73},{17,173}},
{{45,74},{195,107}},{{181,124},{187,62}},{{2,71},{174,17}},{{177,157},{98,20}},{{154,140},{122,97}},
{{134,96},{88,157}},{{90,183},{141,45}},{{27,190},{69,82}},{{163,120},{87,66}},{{104,173},{29,43}},
{{27,26},{86,71}},{{101,185},{96,12}},{{159,82},{5,45}},{{169,45},{2,85}},{{4,164},{98,47}},
{{80,4},{158,178}},{{101,119},{17,40}},{{53,32},{48,157}},{{64,69},{70,20}},{{158,156},{43,186}},
{{41,0},{49,79}},{{45,30},{106,68}},{{33,42},{116,119}},{{84,173},{36,192}},{{162,161},{5,6}},
{{32,18},{91,190}},{{82,109},{93,62}},{{127,109},{103,23}},{{120,41},{117,199}},{{197,109},{65,192}},
{{191,24},{87,70}},{{94,181},{172,178}},{{8,52},{78,74}},{{61,110},{195,96}},{{31,125},{129,44}},
{{175,195},{75,123}},{{194,54},{1,1}},{{130,33},{98,51}},{{198,89},{67,96}},{{131,140},{32,22}},
{{99,146},{0,140}},{{5,58},{114,67}},{{33,37},{146,98}},{{74,142},{72,102}},{{137,170},{181,30}},
{{20,95},{122,147}},{{181,199},{194,30}},{{45,188},{146,21}},{{190,43},{50,61}},{{193,136},{49,127}},
{{191,43},{49,99}},{{164,80},{50,198}},{{180,102},{198,63}},{{36,18},{114,166}},{{163,140},{8,103}},
{{136,123},{16,1}},{{93,160},{12,63}},{{44,171},{195,91}},{{151,92},{87,120}},{{0,180},{184,32}},
{{111,27},{144,169}},{{49,88},{121,13}},{{182,66},{33,152}},{{64,122},{158,88}},{{109,23},{139,47}},
{{99,151},{132,111}},{{96,1},{157,164}},{{190,133},{83,13}},{{109,130},{93,7}},{{104,66},{33,99}},
{{22,147},{149,141}},{{47,150},{95,1}},{{54,81},{92,76}},{{66,26},{120,94}},{{25,168},{176,159}},
{{88,73},{188,37}},{{17,126},{133,96}},{{53,49},{195,94}},{{178,144},{144,37}},{{42,91},{8,50}},
{{115,199},{58,177}},{{143,137},{79,48}},{{7,72},{21,96}},{{57,99},{25,68}},{{125,2},{39,135}},
{{2,113},{178,28}},{{136,181},{176,36}},{{12,98},{160,25}},{{70,48},{60,66}},{{101,140},{130,118}}};

int sizenums = 200;

int currentindex = 0;
int localresults[nthreads];
int gmin; 
int gindexmin;


bool done = false;

std::atomic<bool> cancel;



bool intersection(double x1, double  y1, double x2, double y2, double x3, double y3, double x4, double y4){
    long base = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);
    if(base == 0){
        return false;
    }
    double sub1 = x1*y2 - y1*x2;
    double sub2 = x3*y4 - y3*x4;
    double px = sub1*(x3 - x4) - (x1 - x2)*sub2;
    px = px / base;
    double py = sub1*(y3 - y1) - (y1-y2)*sub2;
    py = py / base;

    std::vector<double> xs = {x1, x2, x3, x4};
    std::sort(xs.begin(), xs.end());

    if(px >= xs[1] && px <= xs[2]){
        return true;
    }
    else{
        return false;
    }
}

pthread_barrier_t barrier;

struct data{
    int id;
};


void * thread_function(void * args){

    struct data *in_args = (struct data *) args;
    int id = in_args->id;

    int flag = pthread_barrier_wait(&barrier);
    if(flag == PTHREAD_BARRIER_SERIAL_THREAD){
        gmin = -1;
        gindexmin = -1;
        currentindex = 0;
        done = false;

    }
    pthread_barrier_wait(&barrier);

    while(1){
        
        if(done){
            pthread_exit(NULL);
        }
        int i = currentindex;
        int localcount = 0;
        for(int j = id; j<sizenums; j = j + nthreads){
            if(i == j) continue;
            if(cancel.load(std::memory_order_relaxed)) break;
            if(intersection(nums[i][0][0], nums[i][0][1], nums[i][1][0], nums[i][1][1], nums[j][0][0], nums[j][0][1], nums[j][1][0], nums[j][1][1])) localcount++;
            if(localcount >= gmin && gmin >= 0){
                cancel.store(true, std::memory_order_relaxed);
            }
        }
        localresults[id] = localcount;


        flag = pthread_barrier_wait(&barrier);
        if(flag == PTHREAD_BARRIER_SERIAL_THREAD){
            if(cancel.load(std::memory_order_relaxed)){
                cancel.store(false, std::memory_order_relaxed);
            }
            else{
                int total = 0;
                for(int myi = 0; myi<nthreads; myi++){
                    total = total + localresults[myi];
                }
                if(total <= gmin || gmin < 0){
                    gmin = total;
                    gindexmin = currentindex;
                }

            }
            currentindex++;
            if(currentindex >= sizenums){
                done = true;
            }

        }
        pthread_barrier_wait(&barrier);
    }
}

int main(){
    pthread_barrier_init(&barrier, NULL ,4);

    pthread_t pool[4];
    struct data args[4];

    cancel.store(false, std::memory_order_relaxed);

    for(int i = 0; i<4; i++){
        args[i].id = i;
    }
    
    for(int i = 0; i<4; i++){
        pthread_create(&pool[i], NULL, thread_function, (void *) &args[i]);
    }
    
    for(int i=0; i<4; i++){
        pthread_join(pool[i], NULL);
    }

    printf("%d, %d\n", gindexmin, gmin);


}